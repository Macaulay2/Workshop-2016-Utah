--%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
----------------------------------------------------------------------------------
-- CONTENTS
----------------------------------------------------------------------------------
--%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

----------------------------------------------------------------------------------
-- Nu computations

-- Main functions: nuList, nu, nuListAlt, nuAlt, nuListAlt1, nuHatList, nuHat

-- Auxiliary Functions: effRad, effPolyRad, isJToAInIToPe, binarySearch

----------------------------------------------------------------------------------
-- FThreshold Approxiations

-- Main functions: FPTApproxList, FTApproxList, FTHatApproxList

----------------------------------------------------------------------------------
-- FThreshold Estimates

-- Main functions: guessFPT, estFPT

----------------------------------------------------------------------------------
-- FPT/F-Jumping number check

-- Main functions: isFPTPoly, isFJumpingNumberPoly

--%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
----------------------------------------------------------------------------------
-- Functions for computing \(nu_I)^J(p^e), \(nu_f)^J(p^e)
----------------------------------------------------------------------------------
--%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

-- If I is contained in Rad(J) then this finds the minimal N 
-- such that I^N is contained in J

effRad = ( I, J ) -> 
(
    if not isSubset( I, radical( J ) ) then error "The first ideal is not contained in the radical of the second.";
    d := 1;
    while not isSubset( I^d, J ) do d = d+1;
    d
)

-- Computes effRad for a principal ideal generated by f

effPolyRad = ( f, J ) -> 
(
    if not isSubset( ideal( f ), radical( J ) ) then error "The polynomial is not contained in the radical of the ideal.";
    d := 1;
    while not isSubset( ideal( fastExp( f, d ) ), J ) do d = d+1;
    d
)

-- Computes the list of values of nu_I^J(p^d) for d=1,..., e

nuList = method()

nuList(Ideal, Ideal,  ZZ) := (I1, J1, e1) -> ( --this is a faster nuList computation, it tries to do a smart nu list computation
	d1 := 0;
	p1 := char ring I1;
	local top;--for the binary search
	local bottom;--for the binary search
 	local middle;--for the binary search
	local answer; --a boolean for determining if we go up, or down
	
	if isSubset(I1, radical(J1))==false then (print "Error: Nu Undefined")
	else(
	myList := new MutableList;
	nuPrev := effRad(I1,J1);
	N := numgens(trim(J1));
	top = nuPrev*(N*p1-1);
	bottom = 0;
	
	for d1 from 1 to e1 do (
		while (top - 1 > bottom) do (--the bottom value is always not in m, the top is always in m
			middle := floor((top + bottom)/2);
			answer = isSubset(I1^middle, frobeniusPower(J1, d1));
			if (answer == false) then bottom = middle else top = middle;
		);
		nuPrev = bottom;
		myList#(d1-1) = nuPrev;
		top = (nuPrev+1)*(N*p1-1);
		bottom = p1*nuPrev;
	);
	toList myList)
)

-- Computes the list of values of nu_I^J(p^d) for d=1,..., e 
-- when J = maximal ideal

nuList( Ideal, ZZ ) := ( I, e ) -> nuList( I, maxIdeal( ring I ), e )


-- Computes the list of values of nu_I^J(p^d) for d=1,..., e
-- when I=(f) is a principal ideal

nuList(RingElement, Ideal,  ZZ) := (f1, J1, e1) -> ( --this is a faster nuList computation for a polynomial, it tries to do a smart nu list computation
	d1 := 0;
	p1 := char ring f1;
	local top;--for the binary search
	local bottom;--for the binary search
 	local middle;--for the binary search
	local answer; --a boolean for determining if we go up, or down
	
	if isSubset(ideal(f1), radical(J1))==false then (print "Error: Nu Undefined")
	else(
	myList := new MutableList;
	nuPrev := effPolyRad(f1,J1);
	N := numgens(trim(J1));
	top = nuPrev*(N*p1-1);
	bottom = 0;
	
	for d1 from 1 to e1 do (
		while (top - 1 > bottom) do (--the bottom value is always not in m, the top is always in m
			middle := floor((top + bottom)/2);
			answer = isSubset(ideal(fastExp(f1,middle)), frobeniusPower(J1, d1));
			if (answer == false) then bottom = middle else top = middle;
		);
		nuPrev = bottom;
		myList#(d1-1) = nuPrev;
		top = (nuPrev+1)*(N*p1-1);
		bottom = p1*nuPrev;
	);
	toList myList)
)

-- Computes the list of values of nu_I^J(p^d) for d=1,..., e
-- when I=(f) is a principal ideal
-- and J=maximal ideal

nuList( RingElement, ZZ ) := ( f, e ) -> nuList( f, maxIdeal( ring f ), e )

-- Computes the value of (nu_I)^J(p^e)

nu = method()

nu(Ideal, Ideal, ZZ) := (I1, J1, e1) -> ( --this does a fast nu computation
	p1 := char ring I1;
	local top;--for the binary search
	local bottom;--for the binary search
	local middle;--for the binary search
	local answer; --a boolean for determining if we go up, or down 
	if isSubset(I1, radical(J1))==false then (print "Error: Nu Undefined")
	else(
	N := 0;
	myList := new MutableList;
	nuPrev := effRad(I1,J1);
	N = numgens(trim(J1));
	top = nuPrev*N*p1^e1-1;
	bottom = 0;
			
	while (top - 1 > bottom) do (--the bottom value is always not in m, the top is always in m
		middle = floor((top + bottom)/2);
		answer = isSubset(I1^middle, frobeniusPower(J1, e1));
		if (answer == false) then bottom = middle else top = middle;
	);
	bottom)
)

-- Computes the value of (nu_I)^J(p^e) 
-- when J=maximal ideal

nu( Ideal, ZZ ) := ( I, e ) -> nu( I, maxIdeal( ring I ), e )


-- Computes the value of (nu_I)^J(p^e) 
-- when I=(f) a principal ideal

nu(RingElement, Ideal, ZZ) := (f1, J1, e1) -> ( --this does a fast nu computation for a polynomial
	p1 := char ring f1;
	local top;--for the binary search
	local bottom;--for the binary search
	local middle;--for the binary search
	local answer; --a boolean for determining if we go up, or down 
	if isSubset(ideal(f1), radical(J1))==false then (print "Error: Nu Undefined")
	else(
	N := 0;
	myList := new MutableList;
	nuPrev := effPolyRad(f1,J1);
	N = numgens(trim(J1));
	top = nuPrev*N*p1^e1-1;
	bottom = 0;
			
	while (top - 1 > bottom) do (--the bottom value is always not in m, the top is always in m
		middle = floor((top + bottom)/2);
		answer = isSubset(ideal(fastExp(f1,middle)), frobeniusPower(J1, e1));
		if (answer == false) then bottom = middle else top = middle;
	);
	bottom)
)

-- Computes the value of (nu_I)^J(p^e) 
-- when I=(f) a principal ideal 
-- and J=maximal ideal

nu( RingElement, ZZ ) := ( f, e ) -> nu( f, maxIdeal( ring f ), e )

-- isJToAInIToPe checks whether or not J^a is in I^(p^e).
-- It seems to be much faster than raising J to a power.
-- Allows tests with ridiculously large exponents
isJToAInIToPe = ( J, a, I, e ) -> isSubset( ethRoot( J, a, e ), I )

-- binarySearch(I, J, e, int) searches for (nu_I)^J(p^e) in the interval int = {a,b}.
-- It is assumed that a<=nu<b.
binarySearch = ( I, J, e, int ) -> 
(
    a := int#0;
    b := int#1;
    if b <= a+1 then return a;
    c := floor( (a+b)/2 );
    if isJToAInIToPe( I, c, J, e ) 
        then binarySearch( I, J, e, { a, c } ) 
	else binarySearch( I, J, e, { c, b } )
)

-- This is essentially the old nuList command, which uses pth roots, 
-- fixed and slightly streamlined 
nuListAlt = method(); 

nuListAlt( Ideal, Ideal, ZZ ) := ( I, J, n ) -> 
( 
    theList := { };
    p := char ring I;
    nu := effRad( I, J ) - 1; -- nu(p^0)
    N := if (numgens trim I) == 1 then p else (numgens trim J)*(p-1)+1;
    scan( 1..n, e -> 
	(
	    nu = binarySearch( I, J, e, { p*nu, (nu+1)*N } );
    	    theList = append( theList, nu );
    	)
    );
    theList	    
)

nuListAlt( RingElement, Ideal, ZZ ) := ( f, J, n ) -> nuListAlt( ideal( f ), J, n )

-- nu lists with respect to the homogeneous maximal ideal
nuListAlt( Ideal, ZZ ) := ( I, n ) -> nuListAlt( I, maxIdeal( ring I ), n )

nuListAlt( RingElement, ZZ ) := ( f, n ) -> nuListAlt( f, maxIdeal( ring f ), n )

-- nuAlt computes individual nus
-- (it simply grabs the last element of a nuList)
nuAlt = method();

nuAlt( Ideal, Ideal, ZZ ) := ( I, J, e ) -> last nuListAlt( I, J, e )

nuAlt( RingElement, Ideal, ZZ ) := ( f, J, e ) -> last nuListAlt( f, J, e )

-- nu with respect to the homogeneous maximal ideal
nuAlt( Ideal, ZZ ) := ( I, e ) -> nuAlt( I, maxIdeal( ring I ), e )

nuAlt( RingElement, ZZ ) := ( f, e ) -> nuAlt( f, maxIdeal( ring f ), e )

-- This is a different approach to nuList, that uses colon ideals. 
nuListAlt1 = method();

nuListAlt1( RingElement, Ideal, ZZ ) := ( f, J, n ) ->  
(
    p := char ring f;
    nu := effPolyRad( f, J ) - 1;  -- nu(p^0)
    theList := { nu };
    I := J;
    scan( 1..n, e ->
	(
	    I = I: ideal( f^nu );
	    nu = binarySearch( f, I, 1, { 0, p } );
	    theList = append( theList, p*(last theList) + nu );
	    I = frobeniusPower( I, 1 ); 
	)
    );
    theList
)    

nuListAlt1( RingElement, ZZ ) := ( f, n ) -> nuListAlt1( f, maxIdeal( ring f ), n )


-- Computes the list of values of \(nuHat_I)^J(p^d) for d=1,..., e
nuHatList = method()

nuHatList(Ideal, Ideal,  ZZ) := (I1, J1, e1) -> ( --this is a faster nuList computation, it tries to do a smart nu list computation
	d1 := 0;
	p1 := char ring I1;
	local top;--for the binary search
	local bottom;--for the binary search
 	local middle;--for the binary search
	local answer; --a boolean for determining if we go up, or down
    	if isSubset(I1, radical(J1))==false then (print "Error: NuHat Undefined")
	else(
	myList := new MutableList;
	nuPrev := effRad(I1,J1);
--	N = numgens(trim(J1));
	top =nuPrev*p1;
	bottom = 0;
	
	
	for d1 from 1 to e1 do (
		while (top - 1 > bottom) do (--the bottom value is always not in m, the top is always in m
			middle := floor((top + bottom)/2);
			answer = isSubset(genFrobeniusPower(I1,middle), frobeniusPower(J1,d1));
			if (answer == false) then bottom = middle else top = middle;
		);
		nuPrev = bottom;
		myList#(d1-1) = bottom;
		top = p1*(nuPrev+1);
		bottom = p1*nuPrev;
	);
	toList myList)
)

-- Computes the list of values of \(nuHat_I)^J(p^d) for d=1,..., e
-- when for J=maximal ideal

nuHatList( Ideal, ZZ ) := ( I, e ) -> nuHatList( I, maxIdeal( ring I ), e )

-- Computes the list of values of \(nuHat_I)^J(p^d) for d=1,..., e
-- when I=(f) is a principal ideal

nuHatList( RingElement, Ideal, ZZ ) := ( f, J, e ) -> nuList( f, J, e ) 

-- Computes the list of values of \(nuHat_I)^J(p^d) for d=1,..., e
-- when I=(f) is a pricipal ideal and J=maximal ideal
 
nuHatList( RingElement, ZZ ) := ( f, e ) -> nuList( f, e ) 


-- Computes values of \(nuHat_I)^J(p^e)

nuHat = method()

nuHat (Ideal, Ideal, ZZ) := (I1, J1, e1) -> ( --this does a fast nu computation
	p1 := char ring I1;
	local top;--for the binary search
	local bottom;--for the binary search
	local middle;--for the binary search
	local answer; --a boolean for determining if we go up, or down
    	if isSubset(I1, radical(J1))==false then (print "Error: NuHat Undefined")
	else(
	myList := new MutableList;
	nuPrev := effRad(I1,J1);
--	N = numgens(trim(J1));
	top = nuPrev*p1^e1;
	bottom = 0;
			
	while (top - 1 > bottom) do (--the bottom value is always not in m, the top is always in m
		middle = floor((top + bottom)/2);
		answer = isSubset(genFrobeniusPower(I1, middle), frobeniusPower(J1,e1));
		if (answer == false) then bottom = middle else top = middle;
	);
	bottom)
)


-- Computes values of \(nuHat_I)^J(p^e)
-- when J=maximal ideal

nuHat( Ideal, ZZ ) := ( I, e ) -> nuHat( I, maxIdeal( ring I ), e )

-- Computes  values of \(nuHat_I)^J(p^e)
-- when I=(f) is a principal ideal

nuHat( RingElement, Ideal, ZZ ) := ( f, J, e ) -> nu( f, J, e )

-- Computes  values of \(nuHat_I)^J(p^e)
-- when I=(f) is a principal ideal 
-- and J=maximal ideal 

nuHat( RingElement, ZZ ) := ( f, e ) -> nu( f, e )

--%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
----------------------------------------------------------------------------------
-- Functions for approximating, guessing, estimating F-Thresholds
----------------------------------------------------------------------------------
--%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

--Approximates the F-pure Threshold
--Gives a list of nu_I(p^d)/p^d for d=1,...,e
FPTApproxList = method();

FPTApproxList (Ideal,ZZ) := (I,e) ->
(
     p := char ring I;
     nus := nuList(I,e);
     apply( nus, 1..e, (n,k) -> n/p^k )
)

FPTApproxList (RingElement,ZZ) := (f,e) -> FPTApproxList(ideal(f),e)

--Approximates the F-Threshold with respect to an ideal J
--More specifically, this gives a list of nu_I^J(p^d)/p^d for d=1,...,e

FTApproxList = method();

FTApproxList (Ideal,Ideal,ZZ) := (I,J,e) ->
(
    if not isSubset( I, radical(J) ) then error "F-threshold undefined.";
     p := char ring I;
     nus := nuList(I,J,e);
     apply( nus, 1..e, (n,k) -> n/p^k )
)

FTApproxList (RingElement,Ideal,ZZ) := (f1,J1,e1) -> FTApproxList(ideal(f1),J1,e1)

FTHatApproxList = method();

FTHatApproxList (Ideal,Ideal,ZZ) := (I,J,e) ->
(
    if not isSubset( I, radical(J) ) then error "F-threshold undefined.";
     p := char ring I;
     nus := nuHatList(I,J,e);
     apply( nus, 1..e, (n,k) -> n/p^k )
)

FTHatApproxList (RingElement,Ideal,ZZ) := (f1,J1,e1) -> FTHatApproxList(ideal(f1),J1,e1)


--Guesses the FPT of ff.  It returns a list of all numbers in 
--the range suggested by nu(ff,e1) with maxDenom as the maximum denominator
guessFPT ={OutputRange=>false}>>o -> (ff, e1, maxDenom) ->(
     nn := nu(ff, e1);
     pp := char ring ff;
     if (o.OutputRange == false) then 
          findNumberBetween({nn/(pp^e1-1), (nn+1)/(pp^e1)}, maxDenom)
     else
          {{ nn/(pp^e1-1), (nn+1)/(pp^e1)}, findNumberBetween({nn/(pp^e1-1), (nn+1)/(pp^e1)}, maxDenom)}
)

--F-pure threshold estimation, at the origin
--e is the max depth to search in
--FinalCheck is whether the last isFRegularPoly is run (it is possibly very slow) 
--If MultiThread is set to true, it will compute the two F-signatures simultaneously
estFPT={FinalCheck=> true, Verbose=> false, MultiThread=>false, DiagonalCheck=>true, BinomialCheck=>true, NuCheck=>true} >> o -> (ff,ee)->(
     print "starting estFPT";
     
     maxIdeal := ideal( first entries vars( ring ff) );   --the maximal ideal we are computing the fpt at  

     foundAnswer := false; --this will be set to true as soon as we found the answer.  Setting it to true will stop further tests from being run
     answer := null; --this stores the answer until it can be returned.
     
     --first check if it is diagonal:
     if ( (o.DiagonalCheck==true) and (foundAnswer == false) ) then (
	   if (isDiagonal(ff)==true) then ( 
		if (o.Verbose==true) then print "Polynomial is diagonal."; 
		answer = diagonalFPT(ff); 
		foundAnswer = true
	   )
     );

     --now check if it is binomial:
     if ( (o.BinomialCheck==true) and (foundAnswer == false) ) then (
	  if (isBinomial(ff)==true) then ( 
	       if  (o.Verbose==true) then print "Polynomial is binomial.";
	       answer = binomialFPT(ff);
	       foundAnswer = true
	  )
     );
     
     --compute nu's
     if (foundAnswer == false) then (
     	  pp:=char ring ff;
     	  nn:=nu(ff,ee);
	  if  (o.Verbose==true) then print "nu's have been computed";

     	  --if our nu's aren't fine enough, we just spit back some information
       	  if nn==0 then (
	       answer = {0,1/pp};
	       foundAnswer = true
	   )
      );
 
      --check to see if nu/(p^e-1) is the fpt
      if ((o.NuCheck==true) and (foundAnswer == false)) then (
	   if (isFRegularPoly(ff,(nn/(pp^ee-1)),maxIdeal)==false) then ( 
		if  (o.Verbose==true) then print "Found answer via nu/(p^e-1)."; 
		answer = nn/(pp^ee-1);
		foundAnswer = true
	   ) 
      	   else (
	   	if  (o.Verbose==true) then print "nu/(p^e - 1) is not the fpt.";
	   )
      );
	 
	--check to see if (nu+1)/p^e is the FPT
	if ((o.NuCheck==true) and (foundAnswer == false)) then(
		if (isFPTPoly(ff, (nn+1)/pp^ee,Origin=>true) == true) then (
			answer = (nn+1)/pp^ee;
			foundAnswer = true
		)
	);

     --do the F-signature computation
     if (foundAnswer == false) then (
	   ak := 0;
	   if (o.MultiThread==false ) then (ak=threshInt(ff,ee,(nn-1)/pp^ee,fSig(ff,nn-1,ee),nn) ) else(
		if (o.Verbose==true) then print "Beginning multithreaded F-signature";
		allowableThreads = 4;
		numVars := rank source vars (ring ff);
		YY := local YY;
		myMon := monoid[  toList(YY_1..YY_numVars), MonomialOrder=>RevLex,Global=>false];
		--print myMon;
     		R1:=(coefficientRing ring ff) myMon;
		rMap := map(R1, ring ff, vars myMon);
		gg := rMap(ff);
		
		
		H := (fff,aaa,eee) -> () -> fSig(fff,aaa,eee);
		newSig1 := H(gg,nn-1,ee);
		t1 := schedule newSig1;
	     	s2 := fSig(ff,nn,ee);	
		if (o.Verbose==true) then print "One signature down";
		while ((not isReady t1)) do sleep 1;
		s1 := taskResult t1;
     	      --  print s1; print s2;
		ak = {s2,xInt( (nn-1)/pp^ee, s1, (nn)/pp^ee,s2)};
		--print nn;		
	   );
	   if  (o.Verbose==true) then print "Computed F-signatures.";
	   --now check to see if we cross at (nu+1)/p^e, if that's the case, then that's the fpt.
	   if ( (nn+1)/pp^ee == (ak#1) ) then (
		if  (o.Verbose==true) then print "F-signature line crosses at (nu+1)/p^e."; 
		answer = ak#1;
		foundAnswer = true
	   )
      );	  
      	
      --if we run the final check, do the following
      if ( (foundAnswer == false) and (o.FinalCheck == true)) then ( 
	  if  (o.Verbose==true) then print "Starting FinalCheck."; 
          	if ((isFRegularPoly(ff,(ak#1),maxIdeal)) ==false ) then (	
	      		if  (o.Verbose==true) then print "FinalCheck successful"; 
	      		answer = (ak#1);
	      		foundAnswer = true 
      	  	)
	  		else ( 
	      		if  (o.Verbose==true) then print "FinalCheck didn't find the fpt."; 
	      		answer = {(ak#1),(nn+1)/pp^ee};
	      		foundAnswer = true
	  		)
       );
       
       --if we don't run the final check, do the following
       if ((foundAnswer == false) and (o.FinalCheck == false) ) then (
	  if  (o.Verbose==true) then print "FinalCheck not run.";
	  answer = {(ak#1),(nn+1)/pp^ee};
      	  foundAnswer = true
       );
     
     --return the answer
     answer
)

--%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
----------------------------------------------------------------------------------
-- Functions for checking if given numbers are F-jumping numbers
----------------------------------------------------------------------------------
--%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

--isFPTPoly, determines if a given rational number is the FPT of a pair in a polynomial ring. 
--if Origin is specified, it only checks at the origin. 

isFPTPoly ={Verbose=> false,Origin=>false}>> o -> (f1, t1) -> (
	pp := char ring f1;
	if (o.Origin == true) then org := ideal(vars (ring f1));
	funList := divideFraction(t1, pp);
	--this writes t1 = a/(p^b(p^c-1))
	aa := funList#0;
	bb := funList#1;
	cc := funList#2;
	mySigma := ideal(f1);
	myTau := ideal(sub(1, ring f1));
	myA := aa;
	myA2 := 0;
	
	if (cc != 0) then (
		myA = floor(aa / (pp^cc - 1));
		myTau = tauPoly( f1, (aa%(pp^cc-1))/(pp^cc-1) )
	);
	
	if (o.Verbose==true) then print "higher tau Computed";

	--first we check whether this is even a jumping number.
	if (cc == 0) then (
		myA2 = aa-1;
		mySigma = sigmaAOverPEMinus1Poly(f1, (pp-1), 1)
	)
	else (
		myA2 = floor((aa-1)/(pp^cc-1));
		mySigma = (sigmaAOverPEMinus1Poly(f1, ((aa-1)%(pp^cc-1))+1, cc))
	);
	if (o.Verbose==true) then print "higher sigma Computed";

	returnValue := false;
	
	if ( isSubset(ideal(sub(1, ring f1)), ethRootSafe(f1, mySigma, myA2, bb) )) then (
		if (o.Verbose==true) then print "we know t1 <= FPT";
		if (not isSubset(ideal(sub(1, ring f1)), ethRootSafe(f1, myTau, myA, bb) ))  then returnValue = true 
	);
		
	returnValue
)

--isFJumpingNumberPoly determines if a given rational number is an F-jumping number
--***************************************************************************
--This needs to be speeded up, like the above function
--***************************************************************************
isFJumpingNumberPoly ={Verbose=> false}>> o -> (f1, t1) -> (
	pp := char ring f1;
	funList := divideFraction(t1, pp);
	--this writes t1 = a/(p^b(p^c-1))
	aa := funList#0;
	bb := funList#1;
	cc := funList#2;
	mySigma := ideal(f1);
	myTau := ethRoot(tauPoly(f1, t1*pp^bb), bb);
	if (o.Verbose==true) then print "higher tau Computed";

	--first we check whether this is even a jumping number.
	if (cc == 0) then
		mySigma = ethRoot((ideal(f1^(aa-1)))*((sigmaAOverPEMinus1Poly(f1, (pp-1), 1))), bb)
	else 
		mySigma = ethRoot((sigmaAOverPEMinus1Poly(f1, aa, cc)),bb);
	if (o.Verbose==true) then print "sigma Computed";

	not (isSubset(mySigma, myTau))
)

